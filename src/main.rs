extern crate clap;
use clap::{Arg,AppSettings, App};
use dnasr::{run_generate,run_search,Generate_Config,Search_Config};
use std::process;


fn main() {
    let matches = App::new("DNAS") //main app with two subcommands available, subcommand must be specified
                  .version("1.0")
                  .author("Lukas M.")
                  .about("Shazam on DNA")
                  .long_about("Adaptation of the Shazam algorithm to handle DNA input. For more information and examples visit GIHUBLINK")
                  .setting(AppSettings::AllowExternalSubcommands)
                  .setting(AppSettings::SubcommandRequiredElseHelp)
                  .subcommand(App::new("generate")  //first subcommand "generate" with its arguments
                        .about("Generate queries and databases.")
                        .arg(Arg::with_name("input_file")
                                .short("i")
                                .value_name("FILE")
                                .help("FASTA or FASTQ file with sequences.")
                                .takes_value(true)
                                .required(true))
                        /*.arg(Arg::with_name("meth")
                                .long("meth")
                                .help("Option for consideration of methylation pattern.")
                                .value_name("BOOL")
                                .takes_value(true)
                                .required(true))*/
                        .arg(Arg::with_name("output_dir")
                                .short("o")
                                .help("Output directory.")
                                .value_name("DIR")
                                .takes_value(true)
                                .required(true))
                        .arg(Arg::with_name("window")
                                .short("w")
                                .help("Size of scanning window.")
                                .value_name("INT")
                                .takes_value(true)
                                .default_value("150"))
                        .arg(Arg::with_name("kmer")
                                .short("k")
                                .help("Kmer sizes to use.")
                                .value_name("INT")
                                .takes_value(true)
                                .default_value("3"))
                        .arg(Arg::with_name("np")
                                .long("np")
                                .help("Number of processes to use.")
                                .value_name("INT")
                                .takes_value(true)
                                .default_value("1"))
                        .arg(Arg::with_name("matrix_dim")
                                .long("mat")
                                .help("Columns in matrix.")
                                .value_name("INT")
                                .takes_value(true)
                                .default_value("100"))
                        .arg(Arg::with_name("sub_matrix")
                                .long("sub_mat")
                                .value_name("INT")
                                .help("Dimension of quadratic sub matrices.")
                                .takes_value(true)
                                .default_value("4"))
                        .arg(Arg::with_name("database")
                                .long("db")
                                .help("Generate output as database or not.")
                                .value_name("BOOL")
                                .takes_value(true)
                                .required(true))
                        .arg(Arg::with_name("offset")
                                .long("off")
                                .value_name("INT")
                                .help("Offset between anchor and target zone.")
                                .takes_value(true)
                                .default_value("3"))
                        .arg(Arg::with_name("early_exit")
                                .long("ee")
                                .value_name("BOOL")
                                .help("Subcommand generate should exit early and give raw information entropy.")
                                .takes_value(true)
                                .default_value("false")))
                  .subcommand(App::new("search")  //second subcommand "search" with its arguments
                        .about("Search passed database with passed query.")
                        .arg(Arg::with_name("query")
                                .short("q")
                                .value_name("FILE")
                                .help("Input file with query. Query generated by \"dnas generate\". ")
                                .takes_value(true)
                                .required(true))
                        .arg(Arg::with_name("database")
                                .long("db")
                                .value_name("FILE")
                                .help("Database to search with passed query.")
                                .takes_value(true)
                                .required(true))
                        .arg(Arg::with_name("output_dir")
                                .short("o")
                                .value_name("DIR")
                                .help("Output directory.")
                                .takes_value(true)
                                .required(true)))
                  .get_matches();

    match matches.subcommand() {
        ("generate",Some(generate_matches)) => if let Err(e) = run_generate(Generate_Config::new(generate_matches)){  //handoff to run_generate function and small error handling
            eprintln!("Application error: {}", e);
            process::exit(1);
            },
        ("search",Some(search_matches)) => if let Err(e) = run_search(Search_Config::new(search_matches)){  //handoff to run_search function and small error handling
            eprintln!("Application error: {}", e);
            process::exit(1);
            },
        _ => process::exit(1)
    }
}
